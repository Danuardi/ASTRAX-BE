# Agent Service Integration Guide

Panduan untuk implementasi Agent Service yang berkomunikasi dengan Backend via Redis Queue dan Pub/Sub.

---

## Architecture Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  AGENT SERVICE (External Worker/Microservice)                ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    ‚îÇ
‚îÇ  1. BRPOP from queue (blocking)                              ‚îÇ
‚îÇ  2. Process job                                              ‚îÇ
‚îÇ  3. PUBLISH status updates to Redis channel                  ‚îÇ
‚îÇ  4. Update job record in Redis                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚Üë                                      ‚Üì
          ‚îÇ BRPOP                          PUBLISH
          ‚îÇ (Blocking)                     (Status)
          ‚îÇ                                    ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                            ‚îÇ                   ‚îÇ
‚îÇ    Redis Queue                    Redis Pub/Sub Channel       ‚îÇ
‚îÇ    Key: agent:rebalance:jobs     Key: agent:rebalance:status ‚îÇ
‚îÇ    Type: List                     Type: Channel                ‚îÇ
‚îÇ    Op: RPUSH (enqueue)           Op: PUBLISH (broadcast)     ‚îÇ
‚îÇ    Op: BRPOP (dequeue)                                        ‚îÇ
‚îÇ                                            ‚îÇ                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚Üë                                      ‚Üì
          ‚îÇ Job enqueued                    Status received
          ‚îÇ by Backend                      by Backend
          ‚îÇ                                 + forwarded to client
          ‚îÇ                                 via WebSocket
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  BACKEND (Node.js)                                       ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ
‚îÇ  1. POST /agent/rebalance ‚Üí RPUSH jobId                ‚îÇ
‚îÇ  2. Redis Pub/Sub Subscriber (listening)                ‚îÇ
‚îÇ  3. Receive PUBLISH ‚Üí Emit WebSocket to client          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Job Queue Format

### Queue Operations

**Enqueue (by Backend):**
```javascript
// Backend pushes to right (tail)
RPUSH agent:rebalance:jobs "1731304200000-a7f3e2k"
RPUSH agent:rebalance:jobs "1731304200001-b9f4e3l"

// Queue state: [a7f3e2k, b9f4e3l] (a7f3e2k at head for BRPOP)
```

**Dequeue (by Agent):**
```javascript
// Agent pops from left (head) - blocking
BRPOP agent:rebalance:jobs 0  // blocks until item available

// Result: "1731304200000-a7f3e2k"
// Queue state: [b9f4e3l]
```

### Job ID Format

Job IDs are generated by Backend with this format:
```
{timestamp}-{randomHex}

Example: 1731304200000-a7f3e2k

- Timestamp: Unix milliseconds (uniqueness over time)
- Random hex: 4-byte random value (uniqueness in same ms)
```

---

## Agent Implementation Examples

### Example 1: Basic Agent (Node.js with ioredis)

```javascript
const IORedis = require('ioredis');
const redis = new IORedis(process.env.REDIS_URL);

async function runAgent() {
  console.log('ü§ñ Agent starting...');

  while (true) {
    try {
      // 1. Wait for job from queue (blocking)
      console.log('‚è≥ Waiting for jobs...');
      const jobId = await redis.brpop('agent:rebalance:jobs', 0);
      
      if (!jobId) continue;

      const queuedJobId = jobId[1]; // BRPOP returns [key, value]
      console.log(`‚úÖ Got job: ${queuedJobId}`);

      // 2. Get job metadata from Redis
      const jobKey = `agent:rebalance:job:${queuedJobId}`;
      const jobData = await redis.get(jobKey);
      
      if (!jobData) {
        console.warn(`‚ö†Ô∏è  Job metadata not found for ${queuedJobId}`);
        continue;
      }

      const job = typeof jobData === 'string' ? JSON.parse(jobData) : jobData;
      const userId = job.user.publicKey;

      // 3. Process the job
      console.log(`üîÑ Processing job: ${queuedJobId}`);
      
      // Publish "processing" status
      await redis.publish('agent:rebalance:status', JSON.stringify({
        jobId: queuedJobId,
        status: 'processing',
        userId: userId,
        timestamp: new Date().toISOString()
      }));

      // Do actual work here
      const result = await processRebalance(job.payload);

      // 4. Publish completion status
      await redis.publish('agent:rebalance:status', JSON.stringify({
        jobId: queuedJobId,
        status: 'done',
        userId: userId,
        result: result,
        timestamp: new Date().toISOString()
      }));

      console.log(`‚úÖ Job completed: ${queuedJobId}`);

    } catch (err) {
      console.error('‚ùå Agent error:', err.message);

      // Publish error status (if we have jobId)
      if (jobId) {
        await redis.publish('agent:rebalance:status', JSON.stringify({
          jobId: jobId[1],
          status: 'error',
          error: err.message,
          timestamp: new Date().toISOString()
        }));
      }

      // Don't crash, just wait and retry
      await new Promise(r => setTimeout(r, 5000));
    }
  }
}

async function processRebalance(payload) {
  // Simulate processing
  await new Promise(r => setTimeout(r, 2000));
  
  return {
    success: true,
    newBalance: payload.amount * 0.95,
    fee: payload.amount * 0.05
  };
}

runAgent();
```

### Example 2: Agent with Error Handling & Retries

```javascript
const IORedis = require('ioredis');
const redis = new IORedis(process.env.REDIS_URL);

class RebalanceAgent {
  constructor(maxRetries = 3) {
    this.maxRetries = maxRetries;
    this.isRunning = false;
  }

  async start() {
    this.isRunning = true;
    console.log('ü§ñ Agent started');

    while (this.isRunning) {
      try {
        await this.processNextJob();
      } catch (err) {
        console.error('Agent error:', err);
        await this.sleep(5000);
      }
    }
  }

  async processNextJob() {
    // Blocking pop with timeout
    const result = await redis.brpop('agent:rebalance:jobs', 10);
    
    if (!result) {
      // Timeout - no jobs available
      return;
    }

    const jobId = result[1];
    let attempts = 0;

    while (attempts < this.maxRetries) {
      try {
        await this.executeJob(jobId);
        return; // Success
      } catch (err) {
        attempts++;
        console.warn(`Job failed (attempt ${attempts}/${this.maxRetries}): ${err.message}`);
        
        if (attempts >= this.maxRetries) {
          // Final failure - publish error
          const jobKey = `agent:rebalance:job:${jobId}`;
          const jobData = await redis.get(jobKey);
          const job = typeof jobData === 'string' ? JSON.parse(jobData) : jobData;

          await redis.publish('agent:rebalance:status', JSON.stringify({
            jobId,
            status: 'error',
            userId: job.user.publicKey,
            error: err.message,
            attempts,
            timestamp: new Date().toISOString()
          }));
        } else {
          // Retry after delay
          await this.sleep(1000 * attempts);
        }
      }
    }
  }

  async executeJob(jobId) {
    const jobKey = `agent:rebalance:job:${jobId}`;
    const jobData = await redis.get(jobKey);
    
    if (!jobData) {
      throw new Error(`Job metadata not found: ${jobId}`);
    }

    const job = typeof jobData === 'string' ? JSON.parse(jobData) : jobData;
    const userId = job.user.publicKey;

    // Publish processing status
    await redis.publish('agent:rebalance:status', JSON.stringify({
      jobId,
      status: 'processing',
      userId,
      timestamp: new Date().toISOString()
    }));

    // Execute
    const result = await this.executeRebalance(job.payload);

    // Publish done status
    await redis.publish('agent:rebalance:status', JSON.stringify({
      jobId,
      status: 'done',
      userId,
      result,
      timestamp: new Date().toISOString()
    }));
  }

  async executeRebalance(payload) {
    // Validate
    if (!payload.amount || payload.amount <= 0) {
      throw new Error('Invalid amount');
    }

    // Process
    const fee = payload.amount * 0.02;
    const remaining = payload.amount - fee;

    return {
      success: true,
      originalAmount: payload.amount,
      fee,
      remainingAmount: remaining,
      processedAt: new Date().toISOString()
    };
  }

  sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  stop() {
    this.isRunning = false;
    redis.disconnect();
  }
}

const agent = new RebalanceAgent(3);
agent.start();

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('Shutting down...');
  agent.stop();
  process.exit(0);
});
```

### Example 3: Agent with Monitoring

```javascript
const IORedis = require('ioredis');
const prometheus = require('prom-client');

const redis = new IORedis(process.env.REDIS_URL);

// Prometheus metrics
const jobsProcessed = new prometheus.Counter({
  name: 'agent_jobs_processed_total',
  help: 'Total jobs processed',
  labelNames: ['status']
});

const jobsDuration = new prometheus.Histogram({
  name: 'agent_job_duration_seconds',
  help: 'Job processing duration',
  buckets: [1, 5, 10, 30, 60]
});

class MonitoredAgent {
  async processJob(jobId) {
    const startTime = Date.now();

    try {
      // Get job data
      const jobKey = `agent:rebalance:job:${jobId}`;
      const jobData = await redis.get(jobKey);
      const job = JSON.parse(jobData);

      // Publish processing
      await redis.publish('agent:rebalance:status', JSON.stringify({
        jobId,
        status: 'processing',
        userId: job.user.publicKey,
        timestamp: new Date().toISOString()
      }));

      // Process
      const result = await this.doWork(job.payload);

      // Publish done
      await redis.publish('agent:rebalance:status', JSON.stringify({
        jobId,
        status: 'done',
        userId: job.user.publicKey,
        result,
        timestamp: new Date().toISOString()
      }));

      // Record metrics
      jobsProcessed.inc({ status: 'success' });
      jobsDuration.observe((Date.now() - startTime) / 1000);

    } catch (err) {
      jobsProcessed.inc({ status: 'error' });
      throw err;
    }
  }

  async doWork(payload) {
    // Implementation
    return { ok: true };
  }
}
```

---

## Message Format Specification

### Status Update Message

Agent publishes JSON messages with this structure:

```typescript
interface StatusUpdate {
  // Required fields
  jobId: string;           // "1731304200000-a7f3e2k"
  status: 'processing' |   // Job being processed
          'done' |         // Job completed successfully
          'error';         // Job failed
  userId: string;          // User's public key (for routing)
  
  // Optional fields
  timestamp?: string;      // ISO timestamp
  result?: any;            // Job result data
  error?: string;          // Error message (if status='error')
  details?: string;        // Processing details
}
```

### Example Messages

**Processing Started:**
```json
{
  "jobId": "1731304200000-a7f3e2k",
  "status": "processing",
  "userId": "GXHEXYVepv5EQnhq9VYVWkvW6QDMRj4QZA2B2mmKpCzq",
  "timestamp": "2025-11-11T10:30:15.000Z",
  "details": "Starting rebalance calculation"
}
```

**Job Completed:**
```json
{
  "jobId": "1731304200000-a7f3e2k",
  "status": "done",
  "userId": "GXHEXYVepv5EQnhq9VYVWkvW6QDMRj4QZA2B2mmKpCzq",
  "timestamp": "2025-11-11T10:30:45.000Z",
  "result": {
    "success": true,
    "newBalance": 950,
    "fee": 50,
    "txHash": "0x123abc..."
  }
}
```

**Job Failed:**
```json
{
  "jobId": "1731304200000-a7f3e2k",
  "status": "error",
  "userId": "GXHEXYVepv5EQnhq9VYVWkvW6QDMRj4QZA2B2mmKpCzq",
  "timestamp": "2025-11-11T10:31:00.000Z",
  "error": "Insufficient balance for rebalance operation",
  "details": "Required: 1000, Available: 500"
}
```

---

## Redis Commands Reference

### Queue Operations

```bash
# Push job to queue (by Backend)
RPUSH agent:rebalance:jobs "1731304200000-a7f3e2k"

# Wait for job (blocking, by Agent)
BRPOP agent:rebalance:jobs 0        # blocks until available
BRPOP agent:rebalance:jobs 10       # timeout after 10 seconds

# View queue without removing
LRANGE agent:rebalance:jobs 0 -1    # all items
LLEN agent:rebalance:jobs           # count items

# Clear queue (debugging)
DEL agent:rebalance:jobs
```

### Status Publishing

```bash
# Publish status update (by Agent)
PUBLISH agent:rebalance:status '{"jobId":"...","status":"...","userId":"..."}'

# Subscribe to status channel (by Backend - automatic)
SUBSCRIBE agent:rebalance:status
```

### Job Metadata

```bash
# Get job record
GET agent:rebalance:job:1731304200000-a7f3e2k

# Job expires after 24 hours (set by Backend)
EXPIRE agent:rebalance:job:1731304200000-a7f3e2k 86400
```

---

## Best Practices

### 1. Always Publish Status Updates

```javascript
// ‚ùå DON'T: Just process and ignore
const result = await processJob(jobData);

// ‚úÖ DO: Publish status at each step
await redis.publish('agent:rebalance:status', JSON.stringify({
  jobId, status: 'processing', userId
}));
const result = await processJob(jobData);
await redis.publish('agent:rebalance:status', JSON.stringify({
  jobId, status: 'done', userId, result
}));
```

### 2. Include User ID in Every Message

```javascript
// ‚ùå DON'T: Forget userId
await redis.publish('agent:rebalance:status', JSON.stringify({
  jobId, status: 'done'
}));

// ‚úÖ DO: Always include userId for routing
await redis.publish('agent:rebalance:status', JSON.stringify({
  jobId, status: 'done', userId: job.user.publicKey
}));
```

### 3. Handle Errors Gracefully

```javascript
// ‚úÖ DO: Catch and publish errors
try {
  const result = await processJob(jobData);
  await redis.publish('agent:rebalance:status', JSON.stringify({
    jobId, status: 'done', userId, result
  }));
} catch (err) {
  await redis.publish('agent:rebalance:status', JSON.stringify({
    jobId, status: 'error', userId,
    error: err.message,
    details: err.stack
  }));
}
```

### 4. Implement Retry Logic

```javascript
// ‚úÖ DO: Retry failed jobs
async function processWithRetry(jobId, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await processJob(jobId);
    } catch (err) {
      if (attempt === maxRetries) {
        throw err; // Give up
      }
      await sleep(1000 * attempt); // Exponential backoff
    }
  }
}
```

### 5. Log Detailed Information

```javascript
// ‚úÖ DO: Log actions for debugging
console.log(`[Agent] Processing job: ${jobId}`);
console.log(`[Agent] User: ${job.user.publicKey}`);
console.log(`[Agent] Payload:`, job.payload);
console.log(`[Agent] Status: processing`);

// Publish includes timestamp
{
  timestamp: new Date().toISOString(),
  ...
}
```

---

## Deployment Checklist

- [ ] Agent has access to Redis URL
- [ ] Agent can BRPOP from `agent:rebalance:jobs`
- [ ] Agent can PUBLISH to `agent:rebalance:status`
- [ ] Agent handles connection errors and reconnects
- [ ] Agent logs all job processing
- [ ] Agent publishes "processing" status before work
- [ ] Agent publishes "done" or "error" after work
- [ ] Agent includes `userId` in every status message
- [ ] Error messages are informative (not just "error")
- [ ] Agent handles graceful shutdown
- [ ] Agent has monitoring/alerting for failures
- [ ] Agent has retry logic for transient failures

---

## Troubleshooting

**Issue:** Agent not receiving jobs
- ‚úÖ Check queue key: `redis-cli LLEN agent:rebalance:jobs`
- ‚úÖ Check BRPOP syntax and timeout value
- ‚úÖ Check Redis connection is established

**Issue:** Backend not receiving status updates
- ‚úÖ Check channel name: `agent:rebalance:status`
- ‚úÖ Check message format is valid JSON
- ‚úÖ Check server logs for `[Redis Subscribe]` errors
- ‚úÖ Verify Agent is connected to same Redis instance

**Issue:** Client not receiving updates
- ‚úÖ Check `userId` in status message matches client's public key
- ‚úÖ Check WebSocket connection is active
- ‚úÖ Check backend logs for event emission
- ‚úÖ Check client is listening to correct event name

---

## Summary

‚úÖ Agent pops jobs from `agent:rebalance:jobs` queue  
‚úÖ Agent processes job and publishes status to Redis channel  
‚úÖ Backend subscribes to channel and forwards to WebSocket clients  
‚úÖ Clients receive real-time status updates  
‚úÖ Full integration with job tracking system  

**Key Points:**
1. Use BRPOP for blocking queue consumption
2. Publish status after each major step
3. Always include userId for proper routing
4. Handle errors and retry appropriately
5. Log everything for debugging

**Last Updated:** November 11, 2025
